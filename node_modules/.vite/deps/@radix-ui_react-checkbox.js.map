{
  "version": 3,
  "sources": ["../../../../node_modules/@radix-ui/react-checkbox/dist/packages/react/checkbox/src/index.ts", "../../../../node_modules/@radix-ui/react-checkbox/dist/packages/react/checkbox/src/Checkbox.tsx"],
  "sourcesContent": ["export {\n  createCheckboxScope,\n  //\n  Checkbox,\n  CheckboxIndicator,\n  //\n  Root,\n  Indicator,\n} from './Checkbox';\nexport type { CheckboxProps, CheckboxIndicatorProps } from './Checkbox';\n", "import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Checkbox\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_NAME = 'Checkbox';\n\ntype ScopedProps<P> = P & { __scopeCheckbox?: Scope };\nconst [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);\n\ntype CheckedState = boolean | 'indeterminate';\n\ntype CheckboxContextValue = {\n  state: CheckedState;\n  disabled?: boolean;\n};\n\nconst [CheckboxProvider, useCheckboxContext] =\n  createCheckboxContext<CheckboxContextValue>(CHECKBOX_NAME);\n\ntype CheckboxElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface CheckboxProps extends Omit<PrimitiveButtonProps, 'checked' | 'defaultChecked'> {\n  checked?: CheckedState;\n  defaultChecked?: CheckedState;\n  required?: boolean;\n  onCheckedChange?(checked: CheckedState): void;\n}\n\nconst Checkbox = React.forwardRef<CheckboxElement, CheckboxProps>(\n  (props: ScopedProps<CheckboxProps>, forwardedRef) => {\n    const {\n      __scopeCheckbox,\n      name,\n      checked: checkedProp,\n      defaultChecked,\n      required,\n      disabled,\n      value = 'on',\n      onCheckedChange,\n      ...checkboxProps\n    } = props;\n    const [button, setButton] = React.useState<HTMLButtonElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = button ? Boolean(button.closest('form')) : true;\n    const [checked = false, setChecked] = useControllableState({\n      prop: checkedProp,\n      defaultProp: defaultChecked,\n      onChange: onCheckedChange,\n    });\n    const initialCheckedStateRef = React.useRef(checked);\n    React.useEffect(() => {\n      const form = button?.form;\n      if (form) {\n        const reset = () => setChecked(initialCheckedStateRef.current);\n        form.addEventListener('reset', reset);\n        return () => form.removeEventListener('reset', reset);\n      }\n    }, [button, setChecked]);\n\n    return (\n      <CheckboxProvider scope={__scopeCheckbox} state={checked} disabled={disabled}>\n        <Primitive.button\n          type=\"button\"\n          role=\"checkbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          aria-required={required}\n          data-state={getState(checked)}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          value={value}\n          {...checkboxProps}\n          ref={composedRefs}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            // According to WAI ARIA, Checkboxes don't activate on enter keypress\n            if (event.key === 'Enter') event.preventDefault();\n          })}\n          onClick={composeEventHandlers(props.onClick, (event) => {\n            setChecked((prevChecked) => (isIndeterminate(prevChecked) ? true : !prevChecked));\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              // if checkbox is in a form, stop propagation from the button so that we only propagate\n              // one click event (from the input). We propagate changes from an input so that native\n              // form validation works and form events reflect checkbox updates.\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })}\n        />\n        {isFormControl && (\n          <BubbleInput\n            control={button}\n            bubbles={!hasConsumerStoppedPropagationRef.current}\n            name={name}\n            value={value}\n            checked={checked}\n            required={required}\n            disabled={disabled}\n            // We transform because the input is absolutely positioned but we have\n            // rendered it **after** the button. This pulls it back to sit on top\n            // of the button.\n            style={{ transform: 'translateX(-100%)' }}\n          />\n        )}\n      </CheckboxProvider>\n    );\n  }\n);\n\nCheckbox.displayName = CHECKBOX_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * CheckboxIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'CheckboxIndicator';\n\ntype CheckboxIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface CheckboxIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst CheckboxIndicator = React.forwardRef<CheckboxIndicatorElement, CheckboxIndicatorProps>(\n  (props: ScopedProps<CheckboxIndicatorProps>, forwardedRef) => {\n    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;\n    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);\n    return (\n      <Presence present={forceMount || isIndeterminate(context.state) || context.state === true}>\n        <Primitive.span\n          data-state={getState(context.state)}\n          data-disabled={context.disabled ? '' : undefined}\n          {...indicatorProps}\n          ref={forwardedRef}\n          style={{ pointerEvents: 'none', ...props.style }}\n        />\n      </Presence>\n    );\n  }\n);\n\nCheckboxIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype InputProps = Radix.ComponentPropsWithoutRef<'input'>;\ninterface BubbleInputProps extends Omit<InputProps, 'checked'> {\n  checked: CheckedState;\n  control: HTMLElement | null;\n  bubbles: boolean;\n}\n\nconst BubbleInput = (props: BubbleInputProps) => {\n  const { control, checked, bubbles = true, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n\n  // Bubble checked change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked') as PropertyDescriptor;\n    const setChecked = descriptor.set;\n\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event('click', { bubbles });\n      input.indeterminate = isIndeterminate(checked);\n      setChecked.call(input, isIndeterminate(checked) ? false : checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n\n  return (\n    <input\n      type=\"checkbox\"\n      aria-hidden\n      defaultChecked={isIndeterminate(checked) ? false : checked}\n      {...inputProps}\n      tabIndex={-1}\n      ref={ref}\n      style={{\n        ...props.style,\n        ...controlSize,\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }}\n    />\n  );\n};\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nconst Root = Checkbox;\nconst Indicator = CheckboxIndicator;\n\nexport {\n  createCheckboxScope,\n  //\n  Checkbox,\n  CheckboxIndicator,\n  //\n  Root,\n  Indicator,\n};\nexport type { CheckboxProps, CheckboxIndicatorProps };\n"],
  "mappings": "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",
  "names": ["CHECKBOX_NAME", "createCheckboxContext", "createCheckboxScope", "createContextScope", "CheckboxProvider", "useCheckboxContext", "Checkbox", "React", "props", "forwardedRef", "checked", "checkedProp", "checkboxProps", "button", "setButton", "composedRefs", "useComposedRefs", "node", "hasConsumerStoppedPropagationRef", "isFormControl", "Boolean", "closest", "setChecked", "useControllableState", "prop", "defaultProp", "defaultChecked", "onChange", "onCheckedChange", "initialCheckedStateRef", "form", "reset", "current", "addEventListener", "removeEventListener", "$1bpvS$createElement", "__scopeCheckbox", "isIndeterminate", "required", "getState", "disabled", "undefined", "composeEventHandlers", "onKeyDown", "event", "key", "preventDefault", "onClick", "prevChecked", "isPropagationStopped", "stopPropagation", "transform", "INDICATOR_NAME", "CheckboxIndicator", "indicatorProps", "context", "forceMount", "state", "pointerEvents", "style", "BubbleInput", "inputProps", "ref", "usePrevious", "controlSize", "useSize", "control", "input", "inputProto", "window", "HTMLInputElement", "prototype", "descriptor", "Object", "getOwnPropertyDescriptor", "set", "Event", "indeterminate", "call", "dispatchEvent", "bubbles", "position", "opacity", "margin", "Root", "Indicator"]
}
