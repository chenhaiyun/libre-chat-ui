import {
  h,
  s,
  webNamespaces
} from "./chunk-IWZTSP5N.js";
import {
  toText
} from "./chunk-HJ3T7DAD.js";
import {
  katex
} from "./chunk-CVYUZPLC.js";
import "./chunk-RXZNQJE4.js";
import {
  visit
} from "./chunk-7IGYKCIX.js";
import "./chunk-O7VYOREP.js";
import "./chunk-5WWUZCGV.js";

// ../node_modules/hast-util-from-dom/lib/index.js
function fromDom(tree, options) {
  const result = tree ? transform(tree, options || {}) : void 0;
  return result || { type: "root", children: [] };
}
function transform(node, options) {
  const transformed = one(node, options);
  if (transformed && options.afterTransform)
    options.afterTransform(node, transformed);
  return transformed;
}
function one(node, options) {
  switch (node.nodeType) {
    case 1: {
      return element(node, options);
    }
    case 3: {
      return text(node);
    }
    case 8: {
      return comment(node);
    }
    case 9: {
      return root(node, options);
    }
    case 10: {
      return doctype();
    }
    case 11: {
      return root(node, options);
    }
    default: {
      return void 0;
    }
  }
}
function root(node, options) {
  return { type: "root", children: all(node, options) };
}
function doctype() {
  return { type: "doctype" };
}
function text(node) {
  return { type: "text", value: node.nodeValue || "" };
}
function comment(node) {
  return { type: "comment", value: node.nodeValue || "" };
}
function element(node, options) {
  const space = node.namespaceURI;
  const fn = space === webNamespaces.svg ? s : h;
  const tagName = space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName;
  const content = (
    // @ts-expect-error Types are wrong.
    space === webNamespaces.html && tagName === "template" ? node.content : node
  );
  const attributes = node.getAttributeNames();
  const props = {};
  let index = -1;
  while (++index < attributes.length) {
    props[attributes[index]] = node.getAttribute(attributes[index]) || "";
  }
  return fn(tagName, props, all(content, options));
}
function all(node, options) {
  const nodes = node.childNodes;
  const children = [];
  let index = -1;
  while (++index < nodes.length) {
    const child = transform(nodes[index], options);
    if (child !== void 0) {
      children.push(child);
    }
  }
  return children;
}

// ../node_modules/hast-util-from-html-isomorphic/lib/browser.js
var parser = new DOMParser();
function fromHtmlIsomorphic(value, options) {
  const node = (options == null ? void 0 : options.fragment) ? parseFragment(value) : parser.parseFromString(value, "text/html");
  return (
    /** @type {Root} */
    fromDom(node)
  );
}
function parseFragment(value) {
  const template = document.createElement("template");
  template.innerHTML = value;
  return template.content;
}

// ../node_modules/rehype-katex/index.js
var assign = Object.assign;
var source = "rehype-katex";
function rehypeKatex(options) {
  const settings = options || {};
  const throwOnError = settings.throwOnError || false;
  return (tree, file) => {
    visit(tree, "element", (element2) => {
      const classes = element2.properties && Array.isArray(element2.properties.className) ? element2.properties.className : [];
      const inline = classes.includes("math-inline");
      const displayMode = classes.includes("math-display");
      if (!inline && !displayMode) {
        return;
      }
      const value = toText(element2, { whitespace: "pre" });
      let result;
      try {
        result = katex.renderToString(
          value,
          assign({}, settings, { displayMode, throwOnError: true })
        );
      } catch (error_) {
        const error = (
          /** @type {Error} */
          error_
        );
        const fn = throwOnError ? "fail" : "message";
        const origin = [source, error.name.toLowerCase()].join(":");
        file[fn](error.message, element2.position, origin);
        if (error.name !== "ParseError") {
          element2.children = [
            {
              type: "element",
              tagName: "span",
              properties: {
                className: ["katex-error"],
                title: String(error),
                style: "color:" + (settings.errorColor || "#cc0000")
              },
              children: [{ type: "text", value }]
            }
          ];
          return;
        }
        result = katex.renderToString(
          value,
          assign({}, settings, {
            displayMode,
            throwOnError: false,
            strict: "ignore"
          })
        );
      }
      const root2 = fromHtmlIsomorphic(result, { fragment: true });
      element2.children = root2.children;
    });
  };
}
export {
  rehypeKatex as default
};
//# sourceMappingURL=rehype-katex.js.map
